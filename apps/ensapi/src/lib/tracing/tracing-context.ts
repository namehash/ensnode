import { AsyncLocalStorage } from "node:async_hooks";

import type { AttributeValue } from "@opentelemetry/api";

import type { TracingNode, TracingSpan, TracingTrace } from "@ensnode/ensnode-sdk";

/**
 * Custom span implementation that mirrors OTEL's span structure.
 *
 * @dev Generated by Claude
 */
export class Span {
  private static counter = 0;

  public readonly id: string;
  public readonly traceId: string;
  public readonly parentSpanId: string | undefined;
  public readonly name: string;
  public readonly startTime: number;
  public readonly attributes: Record<string, AttributeValue> = {};
  public readonly events: Array<{
    name: string;
    attributes: Record<string, AttributeValue>;
    time: number;
  }> = [];

  private endTime?: number;
  private _status: { code: number; message?: string } = { code: 1 }; // 1 = OK, 2 = ERROR (OTEL codes)

  constructor(
    name: string,
    traceId: string,
    parentSpanId?: string,
    attributes: Record<string, AttributeValue> = {},
  ) {
    this.id = `span-${++Span.counter}-${Date.now()}`;
    this.traceId = traceId;
    this.parentSpanId = parentSpanId;
    this.name = name;
    this.startTime = Date.now() * 1000; // microseconds
    this.attributes = { ...attributes };
  }

  setAttribute(key: string, value: AttributeValue): void {
    this.attributes[key] = value;
  }

  addEvent(name: string, attributes: Record<string, AttributeValue> = {}): void {
    this.events.push({
      name,
      attributes,
      time: Date.now() * 1000, // microseconds
    });
  }

  setStatus(status: { code: "OK" | "ERROR"; message?: string }): void {
    this._status = {
      code: status.code === "OK" ? 1 : 2,
      message: status.message,
    };
  }

  recordException(error: Error): void {
    this.addEvent("exception", {
      "exception.type": error.constructor.name,
      "exception.message": error.message,
      "exception.stacktrace": error.stack || "",
    });
  }

  end(): void {
    this.endTime = Date.now() * 1000; // microseconds
  }

  toTracingSpan(): TracingSpan {
    return {
      scope: "protocol-tracing",
      id: this.id,
      traceId: this.traceId,
      parentSpanContext: this.parentSpanId
        ? { traceId: this.traceId, spanId: this.parentSpanId }
        : undefined,
      name: this.name,
      timestamp: this.startTime,
      duration: (this.endTime || Date.now() * 1000) - this.startTime,
      attributes: this.attributes,
      status: this._status,
      events: this.events,
    };
  }
}

/**
 * Context for tracing that tracks spans per request.
 *
 * @dev Generated by Claude
 */
export interface TracingContext {
  traceId: string;
  spans: Span[];
  activeSpan?: Span;
}

/**
 * AsyncLocalStorage-based context system for protocol tracing
 *
 * @dev Generated by Claude
 */
export class TracingContextManager {
  private static instance: TracingContextManager;
  private storage = new AsyncLocalStorage<TracingContext>();

  /**
   * Gets the singleton instance of TracingContextManager
   */
  static getInstance(): TracingContextManager {
    if (!TracingContextManager.instance) {
      TracingContextManager.instance = new TracingContextManager();
    }
    return TracingContextManager.instance;
  }

  /**
   * Creates a new trace context and runs the function within it
   */
  async runWithTrace<T>(fn: () => Promise<T>): Promise<{ result: T; trace: TracingTrace }> {
    const traceId = `trace-${Date.now()}-${Math.random().toString(36).slice(2, 11)}`;
    const context: TracingContext = {
      traceId,
      spans: [],
      activeSpan: undefined,
    };

    const result = await this.storage.run(context, fn);
    const trace = this.buildTrace(context.spans);

    return { result, trace };
  }

  /**
   * Starts a new span within the current trace context
   */
  async withSpan<T>(
    name: string,
    attributes: Record<string, AttributeValue>,
    fn: (span: Span) => Promise<T>,
  ): Promise<T> {
    const context = this.storage.getStore();
    if (!context) {
      throw new Error("No protocol trace context found. Make sure to call within runWithTrace()");
    }

    const span = new Span(name, context.traceId, context.activeSpan?.id, attributes);

    context.spans.push(span);
    const previousActiveSpan = context.activeSpan;
    context.activeSpan = span;

    try {
      const result = await fn(span);
      span.setStatus({ code: "OK" });
      return result;
    } catch (error) {
      span.setStatus({ code: "ERROR", message: String(error) });
      if (error instanceof Error) {
        span.recordException(error);
      }
      throw error;
    } finally {
      span.end();
      context.activeSpan = previousActiveSpan;
    }
  }

  /**
   * Gets the currently active span
   */
  getActiveSpan(): Span | undefined {
    return this.storage.getStore()?.activeSpan;
  }

  /**
   * Builds a protocol trace tree from collected spans
   */
  private buildTrace(spans: Span[]): TracingTrace {
    const idToNode = new Map<string, TracingNode>();
    const roots: TracingNode[] = [];

    // Convert spans to tracing spans and create nodes
    for (const span of spans) {
      const tracingSpan = span.toTracingSpan();
      idToNode.set(tracingSpan.id, { ...tracingSpan, children: [] });
    }

    // Build parent-child relationships
    for (const node of idToNode.values()) {
      const parentId = node.parentSpanContext?.spanId;
      if (parentId && idToNode.has(parentId)) {
        idToNode.get(parentId)?.children.push(node);
      } else {
        roots.push(node);
      }
    }

    return roots;
  }
}
