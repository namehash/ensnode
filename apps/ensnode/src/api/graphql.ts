/**
 * This is an autogenerated graphql schema, initially based on ponder's, designed to mimic
 * the subgraph graphql api for queries we've deemed relevant (see docs).
 *
 * 1. inlines some ponder internal types
 * 2. removes ponder's encoded id params in favor of literal ids
 * 3. implement subgraph's simpler pagination style with first & skip w/out Page types
 * 4. PascalCase entity names
 */

// here we inline the following types from this original import
// import type { Drizzle, OnchainTable, Schema } from "ponder";
import type { NodePgDatabase } from "drizzle-orm/node-postgres";
import type { PgliteDatabase } from "drizzle-orm/pglite";

export type Drizzle<TSchema extends Schema = { [name: string]: never }> =
  | NodePgDatabase<TSchema>
  | PgliteDatabase<TSchema>;

export type Schema = { [name: string]: unknown };

export const onchain = Symbol.for("ponder:onchain");

export type OnchainTable<
  T extends TableConfig & {
    extra: PgTableExtraConfig | undefined;
  } = TableConfig & { extra: PgTableExtraConfig | undefined },
> = PgTable<T> & {
  [Key in keyof T["columns"]]: T["columns"][Key];
} & { [onchain]: true } & {
  enableRLS: () => Omit<OnchainTable<T>, "enableRLS">;
};

import { pascalCase } from "change-case";
import DataLoader from "dataloader";
import {
  type Column,
  Many,
  One,
  type SQL,
  type TableRelationalConfig,
  and,
  arrayContained,
  arrayContains,
  asc,
  createTableRelationsHelpers,
  desc,
  eq,
  extractTablesRelationalConfig,
  getTableColumns,
  gt,
  gte,
  inArray,
  is,
  like,
  lt,
  lte,
  ne,
  not,
  notInArray,
  notLike,
  or,
} from "drizzle-orm";
import {
  type PgEnum,
  PgEnumColumn,
  PgInteger,
  PgSerial,
  PgTable,
  PgTableExtraConfig,
  TableConfig,
  isPgEnum,
} from "drizzle-orm/pg-core";
import {
  GraphQLBoolean,
  GraphQLEnumType,
  type GraphQLEnumValueConfigMap,
  type GraphQLFieldConfig,
  type GraphQLFieldConfigMap,
  GraphQLFloat,
  type GraphQLInputFieldConfigMap,
  GraphQLInputObjectType,
  type GraphQLInputType,
  GraphQLInt,
  GraphQLList,
  GraphQLNonNull,
  GraphQLObjectType,
  type GraphQLOutputType,
  GraphQLScalarType,
  GraphQLSchema,
  GraphQLString,
} from "graphql";
import { GraphQLJSON } from "graphql-scalars";

type Parent = Record<string, any>;
type Context = {
  getDataLoader: ReturnType<typeof buildDataLoaderCache>;
  metadataStore: any; // NOTE: type metadataStore as any for now
  drizzle: Drizzle<{ [key: string]: OnchainTable }>;
};

type PluralArgs = {
  where?: { [key: string]: number | string };
  first?: number;
  skip?: number;
  orderBy?: string;
  orderDirection?: "asc" | "desc";
};

const DEFAULT_LIMIT = 50 as const;
const MAX_LIMIT = 1000 as const;

const OrderDirectionEnum = new GraphQLEnumType({
  name: "OrderDirection",
  values: {
    asc: { value: "asc" },
    desc: { value: "desc" },
  },
});

export function buildGraphQLSchema(schema: Schema): GraphQLSchema {
  const tablesConfig = extractTablesRelationalConfig(schema, createTableRelationsHelpers);

  const tables = Object.values(tablesConfig.tables) as TableRelationalConfig[];

  const enums = Object.entries(schema).filter((el): el is [string, PgEnum<[string, ...string[]]>] =>
    isPgEnum(el[1]),
  );
  const enumTypes: Record<string, GraphQLEnumType> = {};
  for (const [enumTsName, enumObject] of enums) {
    // Note that this is keyed by enumName (the SQL name) because that's what is
    // available on the PgEnumColumn type. See `columnToGraphQLCore` for context.
    enumTypes[enumObject.enumName] = new GraphQLEnumType({
      name: enumTsName,
      values: enumObject.enumValues.reduce(
        (acc: Record<string, {}>, cur) => ({ ...acc, [cur]: {} }),
        {},
      ),
    });
  }

  // construct Entity_orderBy enums
  const entityOrderByEnums: Record<string, GraphQLEnumType> = {};
  for (const table of tables) {
    // Scalar fields
    const values = Object.keys(table.columns).reduce<GraphQLEnumValueConfigMap>(
      (acc, columnName) => ({
        ...acc,
        [columnName]: { value: columnName },
      }),
      {},
    );

    // TODO: relationships i.e. parent__labelName iff necessary

    entityOrderByEnums[table.tsName] = new GraphQLEnumType({
      name: `${pascalCase(table.tsName)}_orderBy`,
      values,
    });
  }

  const entityFilterTypes: Record<string, GraphQLInputObjectType> = {};
  for (const table of tables) {
    const filterType = new GraphQLInputObjectType({
      name: `${table.tsName}Filter`,
      fields: () => {
        const filterFields: GraphQLInputFieldConfigMap = {
          // Logical operators
          AND: { type: new GraphQLList(filterType) },
          OR: { type: new GraphQLList(filterType) },
        };

        for (const [columnName, column] of Object.entries(table.columns)) {
          const type = columnToGraphQLCore(column, enumTypes);

          // List fields => universal, plural
          if (type instanceof GraphQLList) {
            const baseType = innerType(type);

            conditionSuffixes.universal.forEach((suffix) => {
              filterFields[`${columnName}${suffix}`] = {
                type: new GraphQLList(baseType),
              };
            });

            conditionSuffixes.plural.forEach((suffix) => {
              filterFields[`${columnName}${suffix}`] = { type: baseType };
            });
          }

          // JSON => no filters.
          // Boolean => universal and singular only.
          // All other scalar => universal, singular, numeric OR string depending on type
          if (type instanceof GraphQLScalarType || type instanceof GraphQLEnumType) {
            if (type.name === "JSON") continue;

            conditionSuffixes.universal.forEach((suffix) => {
              filterFields[`${columnName}${suffix}`] = {
                type,
              };
            });

            conditionSuffixes.singular.forEach((suffix) => {
              filterFields[`${columnName}${suffix}`] = {
                type: new GraphQLList(type),
              };
            });

            if (["String", "ID"].includes(type.name)) {
              conditionSuffixes.string.forEach((suffix) => {
                filterFields[`${columnName}${suffix}`] = {
                  type: type,
                };
              });
            }

            if (["Int", "Float", "BigInt"].includes(type.name)) {
              conditionSuffixes.numeric.forEach((suffix) => {
                filterFields[`${columnName}${suffix}`] = {
                  type: type,
                };
              });
            }
          }
        }

        return filterFields;
      },
    });
    entityFilterTypes[table.tsName] = filterType;
  }

  const entityTypes: Record<string, GraphQLObjectType<Parent, Context>> = {};
  const entityPageTypes: Record<string, GraphQLOutputType> = {};

  for (const table of tables) {
    entityTypes[table.tsName] = new GraphQLObjectType({
      name: pascalCase(table.tsName), // NOTE: PascalCase to match subgraph
      fields: () => {
        const fieldConfigMap: GraphQLFieldConfigMap<Parent, Context> = {};

        // Scalar fields
        for (const [columnName, column] of Object.entries(table.columns)) {
          const type = columnToGraphQLCore(column, enumTypes);
          fieldConfigMap[columnName] = {
            type: column.notNull ? new GraphQLNonNull(type) : type,
          };
        }

        // Relations
        const relations = Object.entries(table.relations);
        for (const [relationName, relation] of relations) {
          const referencedTable = tables.find(
            (table) => table.dbName === relation.referencedTableName,
          );
          if (!referencedTable)
            throw new Error(
              `Internal error: Referenced table "${relation.referencedTableName}" not found`,
            );

          const referencedEntityType = entityTypes[referencedTable.tsName];
          const referencedEntityPageType = entityPageTypes[referencedTable.tsName];
          const referencedEntityFilterType = entityFilterTypes[referencedTable.tsName];
          if (
            referencedEntityType === undefined ||
            referencedEntityPageType === undefined ||
            referencedEntityFilterType === undefined
          )
            throw new Error(
              `Internal error: Referenced entity types not found for table "${referencedTable.tsName}" `,
            );

          if (is(relation, One)) {
            const fields = relation.config?.fields ?? [];
            const references = relation.config?.references ?? [];

            if (fields.length !== references.length) {
              throw new Error(
                "Internal error: Fields and references arrays must be the same length",
              );
            }

            fieldConfigMap[relationName] = {
              // Note: There is a `relation.isNullable` field here but it appears
              // to be internal / incorrect. Until we have support for foriegn
              // key constraints, all `one` relations must be nullable.
              type: referencedEntityType,
              resolve: (parent, _args, context) => {
                const loader = context.getDataLoader({
                  table: referencedTable,
                });

                const rowFragment: Record<string, unknown> = {};
                for (let i = 0; i < references.length; i++) {
                  const referenceColumn = references[i]!;
                  const fieldColumn = fields[i]!;

                  const fieldColumnTsName = getColumnTsName(fieldColumn);
                  const referenceColumnTsName = getColumnTsName(referenceColumn);

                  rowFragment[referenceColumnTsName] = parent[fieldColumnTsName];
                }

                const encodedId = rowFragment.id as string;
                if (!encodedId) return null;

                return loader.load(encodedId);
              },
            };
          } else if (is(relation, Many)) {
            // Search the relations of the referenced table for the corresponding `one` relation.
            // If "relationName" is not provided, use the first `one` relation that references this table.
            const oneRelation = Object.values(referencedTable.relations).find(
              (relation) =>
                relation.relationName === relationName ||
                (is(relation, One) && relation.referencedTableName === table.dbName),
            ) as One | undefined;
            if (!oneRelation)
              throw new Error(
                `Internal error: Relation "${relationName}" not found in table "${referencedTable.tsName}"`,
              );

            const fields = oneRelation.config?.fields ?? [];
            const references = oneRelation.config?.references ?? [];

            const referencedEntityOrderByType = entityOrderByEnums[referencedTable.tsName];
            if (!referencedEntityOrderByType)
              throw new Error(`Entity_orderBy Enum not found for ${referencedTable.tsName}`);

            fieldConfigMap[relationName] = {
              type: referencedEntityPageType,
              args: {
                where: { type: referencedEntityFilterType },
                orderBy: { type: referencedEntityOrderByType },
                orderDirection: { type: OrderDirectionEnum },
                first: { type: GraphQLInt },
                skip: { type: GraphQLInt },
              },
              resolve: (parent, args: PluralArgs, context, info) => {
                const relationalConditions = [];
                for (let i = 0; i < references.length; i++) {
                  const column = fields[i]!;
                  const value = parent[references[i]!.name];
                  relationalConditions.push(eq(column, value));
                }

                return executePluralQuery(
                  referencedTable,
                  context.drizzle,
                  args,
                  relationalConditions,
                );
              },
            };
          } else {
            throw new Error(
              `Internal error: Relation "${relationName}" is unsupported, expected One or Many`,
            );
          }
        }

        return fieldConfigMap;
      },
    });

    entityPageTypes[table.tsName] = new GraphQLNonNull(
      new GraphQLList(new GraphQLNonNull(entityTypes[table.tsName]!)),
    );
  }

  const queryFields: Record<string, GraphQLFieldConfig<Parent, Context>> = {};
  for (const table of tables) {
    const entityType = entityTypes[table.tsName]!;
    const entityPageType = entityPageTypes[table.tsName]!;
    const entityFilterType = entityFilterTypes[table.tsName]!;

    const singularFieldName = table.tsName.charAt(0).toLowerCase() + table.tsName.slice(1);
    const pluralFieldName = `${singularFieldName}s`;

    queryFields[singularFieldName] = {
      type: entityType,
      // Find the primary key columns and GraphQL core types and include them
      // as arguments to the singular query type.
      args: Object.fromEntries(
        table.primaryKey.map((column) => [
          getColumnTsName(column),
          {
            type: new GraphQLNonNull(columnToGraphQLCore(column, enumTypes) as GraphQLInputType),
          },
        ]),
      ),
      resolve: async (_parent, args, context) => {
        const loader = context.getDataLoader({ table });

        // The `args` object here should be a valid `where` argument that
        // uses the `eq` shorthand for each primary key column.
        const encodedId = args.id as string;

        return loader.load(encodedId);
      },
    };

    const entityOrderByType = entityOrderByEnums[table.tsName];
    if (!entityOrderByType) throw new Error(`Entity_orderBy Enum not found for ${table.tsName}`);

    queryFields[pluralFieldName] = {
      type: entityPageType,
      args: {
        where: { type: entityFilterType },
        orderBy: { type: entityOrderByType },
        orderDirection: { type: OrderDirectionEnum },
        first: { type: GraphQLInt },
        skip: { type: GraphQLInt },
      },
      resolve: async (_parent, args: PluralArgs, context, info) => {
        return executePluralQuery(table, context.drizzle, args);
      },
    };
  }

  queryFields._meta = {
    type: GraphQLMeta,
    resolve: async (_source, _args, context) => {
      const status = await context.metadataStore.getStatus();
      return { status };
    },
  };

  return new GraphQLSchema({
    // Include these here so they are listed first in the printed schema.
    types: [GraphQLJSON, GraphQLBigInt, GraphQLPageInfo, GraphQLMeta],
    query: new GraphQLObjectType({
      name: "Query",
      fields: queryFields,
    }),
  });
}

const GraphQLPageInfo = new GraphQLObjectType({
  name: "PageInfo",
  fields: {
    hasNextPage: { type: new GraphQLNonNull(GraphQLBoolean) },
    hasPreviousPage: { type: new GraphQLNonNull(GraphQLBoolean) },
    startCursor: { type: GraphQLString },
    endCursor: { type: GraphQLString },
  },
});

const GraphQLBigInt = new GraphQLScalarType({
  name: "BigInt",
  serialize: (value) => String(value),
  parseValue: (value) => BigInt(value as any),
  parseLiteral: (value) => {
    if (value.kind === "StringValue") {
      return BigInt(value.value);
    } else {
      throw new Error(
        `Invalid value kind provided for field of type BigInt: ${value.kind}. Expected: StringValue`,
      );
    }
  },
});

const GraphQLMeta = new GraphQLObjectType({
  name: "Meta",
  fields: { status: { type: GraphQLJSON } },
});

const columnToGraphQLCore = (
  column: Column,
  enumTypes: Record<string, GraphQLEnumType>,
): GraphQLOutputType => {
  if (column.columnType === "PgEvmBigint") {
    return GraphQLBigInt;
  }

  if (column instanceof PgEnumColumn) {
    if (column.enum === undefined) {
      throw new Error(
        `Internal error: Expected enum column "${getColumnTsName(column)}" to have an "enum" property`,
      );
    }
    const enumType = enumTypes[column.enum.enumName];
    if (enumType === undefined) {
      throw new Error(
        `Internal error: Expected to find a GraphQL enum named "${column.enum.enumName}"`,
      );
    }

    return enumType;
  }

  switch (column.dataType) {
    case "boolean":
      return GraphQLBoolean;
    case "json":
      return GraphQLJSON;
    case "date":
      return GraphQLString;
    case "string":
      return GraphQLString;
    case "bigint":
      return GraphQLString;
    case "number":
      return is(column, PgInteger) || is(column, PgSerial) ? GraphQLInt : GraphQLFloat;
    case "buffer":
      return new GraphQLList(new GraphQLNonNull(GraphQLInt));
    case "array": {
      if (column.columnType === "PgVector") {
        return new GraphQLList(new GraphQLNonNull(GraphQLFloat));
      }

      if (column.columnType === "PgGeometry") {
        return new GraphQLList(new GraphQLNonNull(GraphQLFloat));
      }

      const innerType = columnToGraphQLCore((column as any).baseColumn, enumTypes);

      return new GraphQLList(new GraphQLNonNull(innerType));
    }
    default:
      throw new Error(`Type ${column.dataType} is not implemented`);
  }
};

const innerType = (type: GraphQLOutputType): GraphQLScalarType | GraphQLEnumType => {
  if (type instanceof GraphQLScalarType || type instanceof GraphQLEnumType) return type;
  if (type instanceof GraphQLList || type instanceof GraphQLNonNull) return innerType(type.ofType);
  throw new Error(`Type ${type.toString()} is not implemented`);
};

async function executePluralQuery(
  table: TableRelationalConfig,
  drizzle: Drizzle<{ [key: string]: OnchainTable }>,
  args: PluralArgs,
  extraConditions: (SQL | undefined)[] = [],
) {
  const rawTable = drizzle._.fullSchema[table.tsName];
  const baseQuery = drizzle.query[table.tsName];
  if (rawTable === undefined || baseQuery === undefined)
    throw new Error(`Internal error: Table "${table.tsName}" not found in RQB`);

  const limit = args.first ?? DEFAULT_LIMIT;
  if (limit > MAX_LIMIT) {
    throw new Error(`Invalid limit. Got ${limit}, expected <=${MAX_LIMIT}.`);
  }

  const skip = args.skip ?? 0;

  const orderBySchema = buildOrderBySchema(table, args);
  const orderBy = orderBySchema.map(([columnName, direction]) => {
    const column = table.columns[columnName];
    if (column === undefined) {
      throw new Error(`Unknown column "${columnName}" used in orderBy argument`);
    }
    return direction === "asc" ? asc(column) : desc(column);
  });

  const whereConditions = buildWhereConditions(args.where, table.columns);

  const rows = await baseQuery.findMany({
    where: and(...whereConditions, ...extraConditions),
    orderBy,
    limit,
    offset: skip,
  });

  return rows;
}

const conditionSuffixes = {
  universal: ["", "_not"],
  singular: ["_in", "_not_in"],
  plural: ["_has", "_not_has"],
  numeric: ["_gt", "_lt", "_gte", "_lte"],
  string: [
    "_contains",
    "_not_contains",
    "_starts_with",
    "_ends_with",
    "_not_starts_with",
    "_not_ends_with",
  ],
} as const;

const conditionSuffixesByLengthDesc = Object.values(conditionSuffixes)
  .flat()
  .sort((a, b) => b.length - a.length);

function buildWhereConditions(
  where: Record<string, any> | undefined,
  columns: Record<string, Column>,
): (SQL | undefined)[] {
  const conditions: (SQL | undefined)[] = [];

  if (where === undefined) return conditions;

  for (const [whereKey, rawValue] of Object.entries(where)) {
    // Handle the `AND` and `OR` operators
    if (whereKey === "AND" || whereKey === "OR") {
      if (!Array.isArray(rawValue)) {
        throw new Error(
          `Invalid query: Expected an array for the ${whereKey} operator. Got: ${rawValue}`,
        );
      }

      const nestedConditions = rawValue.flatMap((subWhere) =>
        buildWhereConditions(subWhere, columns),
      );

      if (nestedConditions.length > 0) {
        conditions.push(whereKey === "AND" ? and(...nestedConditions) : or(...nestedConditions));
      }
      continue;
    }

    // Search for a valid filter suffix, traversing the list from longest to shortest
    // to avoid ambiguity between cases like `_not_in` and `_in`.
    const conditionSuffix = conditionSuffixesByLengthDesc.find((s) => whereKey.endsWith(s));
    if (conditionSuffix === undefined) {
      throw new Error(`Invariant violation: Condition suffix not found for where key ${whereKey}`);
    }

    // Remove the condition suffix and use the remaining string as the column name.
    const columnName = whereKey.slice(0, whereKey.length - conditionSuffix.length);

    // Validate that the column name is present in the table.
    const column = columns[columnName];
    if (column === undefined) {
      throw new Error(`Invalid query: Where clause contains unknown column ${columnName}`);
    }

    switch (conditionSuffix) {
      case "":
        if (column.columnType === "PgArray") {
          conditions.push(and(arrayContains(column, rawValue), arrayContained(column, rawValue)));
        } else {
          conditions.push(eq(column, rawValue));
        }
        break;
      case "_not":
        if (column.columnType === "PgArray") {
          conditions.push(
            not(and(arrayContains(column, rawValue), arrayContained(column, rawValue))!),
          );
        } else {
          conditions.push(ne(column, rawValue));
        }
        break;
      case "_in":
        conditions.push(inArray(column, rawValue));
        break;
      case "_not_in":
        conditions.push(notInArray(column, rawValue));
        break;
      case "_has":
        conditions.push(arrayContains(column, [rawValue]));
        break;
      case "_not_has":
        conditions.push(not(arrayContains(column, [rawValue])));
        break;
      case "_gt":
        conditions.push(gt(column, rawValue));
        break;
      case "_lt":
        conditions.push(lt(column, rawValue));
        break;
      case "_gte":
        conditions.push(gte(column, rawValue));
        break;
      case "_lte":
        conditions.push(lte(column, rawValue));
        break;
      case "_contains":
        conditions.push(like(column, `%${rawValue}%`));
        break;
      case "_not_contains":
        conditions.push(notLike(column, `%${rawValue}%`));
        break;
      case "_starts_with":
        conditions.push(like(column, `${rawValue}%`));
        break;
      case "_ends_with":
        conditions.push(like(column, `%${rawValue}`));
        break;
      case "_not_starts_with":
        conditions.push(notLike(column, `${rawValue}%`));
        break;
      case "_not_ends_with":
        conditions.push(notLike(column, `%${rawValue}`));
        break;
      default:
        throw new Error(`Invalid Condition Suffix ${conditionSuffix}`);
    }
  }

  return conditions;
}

function buildOrderBySchema(table: TableRelationalConfig, args: PluralArgs) {
  // If the user-provided order by does not include the ALL of the ID columns,
  // add any missing ID columns to the end of the order by clause (asc).
  // This ensures a consistent sort order to unblock cursor pagination.
  const userDirection = args.orderDirection ?? "asc";
  const userColumns: [string, "asc" | "desc"][] =
    args.orderBy !== undefined ? [[args.orderBy, userDirection]] : [];
  const pkColumns = table.primaryKey.map((column) => [getColumnTsName(column), userDirection]);
  const missingPkColumns = pkColumns.filter(
    (pkColumn) => !userColumns.some((userColumn) => userColumn[0] === pkColumn[0]),
  ) as [string, "asc" | "desc"][];
  return [...userColumns, ...missingPkColumns];
}

export function buildDataLoaderCache({ drizzle }: { drizzle: Drizzle<Schema> }) {
  const dataLoaderMap = new Map<TableRelationalConfig, DataLoader<string, any> | undefined>();
  return ({ table }: { table: TableRelationalConfig }) => {
    const baseQuery = (drizzle as Drizzle<{ [key: string]: OnchainTable }>).query[table.tsName];
    if (baseQuery === undefined)
      throw new Error(`Internal error: Unknown table "${table.tsName}" in data loader cache`);

    let dataLoader = dataLoaderMap.get(table);
    if (dataLoader === undefined) {
      dataLoader = new DataLoader(
        async (ids) => {
          // NOTE: use literal ids against id column
          const idConditions = ids.map((id) => eq(table.columns["id"]!, id));

          const rows = await baseQuery.findMany({
            where: or(...idConditions),
            limit: ids.length,
          });

          return ids.map((id) => rows.find((row) => row.id === id));
        },
        { maxBatchSize: 1_000 },
      );
      dataLoaderMap.set(table, dataLoader);
    }

    return dataLoader;
  };
}

function getColumnTsName(column: Column) {
  const tableColumns = getTableColumns(column.table);
  return Object.entries(tableColumns).find(([_, c]) => c.name === column.name)![0];
}
