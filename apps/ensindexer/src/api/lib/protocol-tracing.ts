import { withActiveSpanAsync } from "@/lib/auto-span";
import { type AttributeValue, type Span, trace } from "@opentelemetry/api";
import { ExportResult, ExportResultCode, hrTimeToMicroseconds } from "@opentelemetry/core";
import { ReadableSpan, SpanExporter } from "@opentelemetry/sdk-trace-base";

const PROTOCOL_TRACING_SCOPE = "protocol-tracing";
const tracer = trace.getTracer(PROTOCOL_TRACING_SCOPE);

type ProtocolSpan = ReturnType<typeof spanToJson>;

const spanToJson = (span: ReadableSpan) => ({
  id: span.spanContext().spanId,
  parentSpanContext: span.parentSpanContext,
  traceId: span.spanContext().traceId,
  name: span.name,
  timestamp: hrTimeToMicroseconds(span.startTime),
  duration: hrTimeToMicroseconds(span.duration),
  // only export `ens.*` attributes to avoid leaking internal details
  attributes: Object.fromEntries(
    Object.entries(span.attributes).filter(([key]) => key.startsWith("ens.")),
  ),
  status: span.status,
  events: span.events,
});

type ProtocolTrace = ProtocolSpan[];

export class ProtocolTraceExporter implements SpanExporter {
  private static _instance: ProtocolTraceExporter | null = null;
  private spans: ReadableSpan[] = [];

  private constructor() {}

  static singleton(): ProtocolTraceExporter {
    if (!this._instance) this._instance = new ProtocolTraceExporter();
    return this._instance;
  }

  export(spans: ReadableSpan[], resultCallback: (result: ExportResult) => void): void {
    this.spans.push(
      ...spans
        // only track traces that are generated by this module's tracer
        .filter((span) => span.instrumentationScope.name === PROTOCOL_TRACING_SCOPE),
    );
    resultCallback({ code: ExportResultCode.SUCCESS });
  }

  getTrace(traceId: string | undefined): ProtocolTrace {
    if (!traceId) return [];

    const spanInTrace = (span: ReadableSpan) => span.spanContext().traceId === traceId;

    const spansInTrace = this.spans.filter(spanInTrace);
    this.spans = this.spans.filter((span) => !spanInTrace(span));
    return spansInTrace.map(spanToJson);
  }

  shutdown(): Promise<void> {
    this.spans = [];
    return Promise.resolve();
  }
}

export enum TraceableENSProtocol {
  ForwardResolution = "forward-resolution",
  ReverseResolution = "reverse-resolution",
}

export enum ReverseResolutionProtocolStep {
  Operation = "operation",
  ForwardResolveCoinType = "forward-resolve-coinType",
  SpecificNameRecordExists = "specific-name-record-exists-check",
  ForwardResolveDefaultCoinType = "forward-resolve-default-coinType",
  DefaultNameRecordExists = "default-name-record-exists-check",
  ForwardResolveAddressRecord = "forward-resolve-address-record",
  VerifyResolvedAddressExistence = "verify-resolved-address-existence",
  VerifyResolvedAddressValidity = "verify-resolved-address-validity",
  VerifyResolvedAddressMatchesAddress = "verify-resolved-address-matches-address",
}

export enum ForwardResolutionProtocolStep {
  Operation = "operation",
  FindResolver = "find-resolver",
  ActiveResolverExists = "active-resolver-exists",
  AccelerateKnownOffchainLookupResolver = "accelerate-known-offchain-lookup-resolver",
  AccelerateKnownOnchainStaticResolver = "accelerate-known-onchain-static-resolver",
  RequireResolver = "require-resolver",
  ExecuteResolveCalls = "execute-resolve-calls",
}

// executes fn in the context of a semantic ENS Protocol Step
export async function withProtocolStepAsync<
  PROTOCOL extends TraceableENSProtocol,
  STEP extends PROTOCOL extends TraceableENSProtocol.ForwardResolution
    ? ForwardResolutionProtocolStep
    : PROTOCOL extends TraceableENSProtocol.ReverseResolution
      ? ReverseResolutionProtocolStep
      : never,
  Fn extends (span: Span) => Promise<any>,
>(protocol: PROTOCOL, step: STEP, fn: Fn): Promise<ReturnType<Fn>> {
  return withActiveSpanAsync(
    tracer,
    `${protocol}:${step}`,
    // TODO: include results in span attributes?
    {
      "ens.protocol": protocol,
      "ens.protocol.step": step,
    },
    fn,
  );
}

// adds a trace event to the span representing a semantic ENS Protocol Step
export function addProtocolStepEvent<
  PROTOCOL extends TraceableENSProtocol,
  STEP extends PROTOCOL extends TraceableENSProtocol.ForwardResolution
    ? ForwardResolutionProtocolStep
    : PROTOCOL extends TraceableENSProtocol.ReverseResolution
      ? ReverseResolutionProtocolStep
      : never,
>(span: Span, protocol: PROTOCOL, step: STEP, result: AttributeValue) {
  span.addEvent(`${protocol}:${step} (${result})`, {
    "ens.protocol": protocol,
    "ens.protocol.step": step,
    "ens.protocol.step.result": result,
  });
}

export async function captureTrace<Fn extends () => Promise<any>>(
  fn: Fn,
): Promise<{ trace: ProtocolTrace; result: ReturnType<Awaited<Fn>> }> {
  // TODO: make sure there are no race conditions here, not sure how hono & otel work
  const traceId = trace.getActiveSpan()?.spanContext().traceId;
  const result = await fn();
  const _trace = ProtocolTraceExporter.singleton().getTrace(traceId);
  return { result, trace: _trace };
}
