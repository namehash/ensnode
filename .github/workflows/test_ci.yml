name: "Test: CI"

on:
  workflow_dispatch:
  push:
    branches:
      - main
  pull_request:

jobs:
  audit:
    name: "Audit Dependencies"
    runs-on: blacksmith-4vcpu-ubuntu-2204
    steps:
      - uses: actions/checkout@v4
      - uses: ./.github/actions/setup_node_environment
      - run: pnpm audit --audit-level=moderate

  prepublish:
    name: "Build NPM Packages"
    runs-on: blacksmith-4vcpu-ubuntu-2204
    steps:
      - uses: actions/checkout@v4
      - uses: ./.github/actions/setup_node_environment
      - run: pnpm packages:prepublish

  static-analysis:
    name: "Static Analysis"
    runs-on: blacksmith-4vcpu-ubuntu-2204
    steps:
      - uses: actions/checkout@v4
      - uses: ./.github/actions/setup_node_environment

      - name: Run Biome CI
        run: pnpm lint:ci

      - name: Run TypeScript Typecheck
        run: pnpm typecheck

      - name: Check Terraform Format
        run: terraform fmt -recursive -check -diff

  unit-tests:
    name: "Unit Tests"
    runs-on: blacksmith-4vcpu-ubuntu-2204
    steps:
      - uses: actions/checkout@v4
      - uses: ./.github/actions/setup_node_environment
      - run: pnpm test

  openapi-sync-check:
    name: "OpenAPI Spec Sync Check"
    runs-on: blacksmith-4vcpu-ubuntu-2204
    steps:
      - uses: actions/checkout@v4
      - uses: ./.github/actions/setup_node_environment

      - name: Start ENSApi in OpenAPI generate mode
        run: |
          OPENAPI_GENERATE_MODE=true pnpm --filter ensapi start &
          ENSAPI_PID=$!
          echo "$ENSAPI_PID" > ensapi.pid
          echo "ENSAPI_PID=$ENSAPI_PID" >> "$GITHUB_ENV"

          # Cleanup function to ensure background process is stopped
          cleanup() {
            echo "Stopping ENSApi (PID: $ENSAPI_PID)..."
            kill $ENSAPI_PID 2>/dev/null || true
            wait $ENSAPI_PID 2>/dev/null || true
          }

          # Wait for server to be ready
          SERVER_READY=false
          for i in {1..30}; do
            # Use --fail to treat non-2xx/3xx responses as failures
            if curl --fail --silent --max-time 5 http://localhost:4334/openapi.json > /dev/null 2>&1; then
              echo "✅ ENSApi is ready and responding with valid OpenAPI spec"
              SERVER_READY=true
              break
            fi
            # Check if the background process is still running
            if ! kill -0 $ENSAPI_PID 2>/dev/null; then
              echo "❌ ENSApi process exited unexpectedly"
              echo "The server process (PID: $ENSAPI_PID) is no longer running."
              exit 1
            fi
            echo "Waiting for ENSApi to start... ($i/30)"
            sleep 1
          done

          if ! kill -0 $ENSAPI_PID 2>/dev/null; then
            echo "❌ ENSApi process exited unexpectedly after starting"
            exit 1
          fi

          if [ "$SERVER_READY" != "true" ]; then
            echo "❌ ENSApi failed to start within 30 seconds"
            echo "The server did not respond to requests at http://localhost:4334/openapi.json"
            cleanup
            exit 1
          fi

      - name: Generate OpenAPI spec from local build
        working-directory: docs/docs.ensnode.io
        run: pnpm openapi:generate http://localhost:4334

      - name: Verify OpenAPI spec matches committed version
        run: |
          if git diff --quiet docs/docs.ensnode.io/openapi.json; then
            echo "✅ OpenAPI spec is in sync with codebase"
          else
            echo "❌ OpenAPI spec is out of sync"
            echo ""
            echo "The committed openapi.json differs from what ENSApi generates:"
            echo ""
            git diff --color docs/docs.ensnode.io/openapi.json
            echo ""
            echo "To fix: OPENAPI_GENERATE_MODE=true pnpm --filter ensapi start"
            echo "Then:   pnpm --filter @docs/mintlify openapi:generate http://localhost:4334"
            echo "Then commit the updated openapi.json."
            exit 1
          fi

      - name: Validate OpenAPI spec with Mintlify
        run: pnpm dlx mintlify openapi-check docs/docs.ensnode.io/openapi.json

      - name: Stop ENSApi
        if: always()
        run: |
          ENSAPI_PID=$(cat ensapi.pid 2>/dev/null) || true
          if [ -n "${ENSAPI_PID:-}" ]; then
            echo "Stopping ENSApi (PID: $ENSAPI_PID)..."
            kill "$ENSAPI_PID" 2>/dev/null || true
            wait "$ENSAPI_PID" 2>/dev/null || true
          fi

  integrity-check:
    name: "Integrity Check"
    runs-on: blacksmith-4vcpu-ubuntu-2204
    services:
      # run postgres alongside this job
      postgres:
        image: postgres:17
        env:
          POSTGRES_DB: postgres
          POSTGRES_USER: postgres
          POSTGRES_PASSWORD: password
        ports:
          - 5432:5432
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
    steps:
      - uses: actions/checkout@v4
      - uses: ./.github/actions/setup_node_environment

      # This will run the dev command in background, and wait up to
      # HEALTH_CHECK_TIMEOUT seconds. It will monitor the log output to
      # ensure the app healthcheck is live. If the command does not
      # print the log with the healthcheck message within that time, the step
      # will exit with a failure.
      # This runtime check uses an ephemeral postgres database that only lives in the CI
      # environment. It will be discarded after the CI run. The app will not
      # check anything beyond the healthcheck as its job is to ensure the app
      # starts successfully only. With the configured RPCs there is likely to
      # be rate limits hit. To prevent that, we use private RPC URLs from
      # GitHub Secrets.
      - name: Run ENSIndexer runtime integrity checks
        env:
          # Note on managing below configuration with GitHub:
          # We use private RPC URLs from GitHub Secrets to avoid rate limits.
          # Public RPC URLs are used as fallbacks for repository forks
          # that don't have the relevant secrets configured.
          NAMESPACE: mainnet
          DATABASE_URL: postgresql://postgres:password@localhost:5432/postgres
          DATABASE_SCHEMA: public
          PLUGINS: subgraph,basenames,lineanames,threedns,protocol-acceleration,registrars,tokenscope
          ENSRAINBOW_URL: https://api.ensrainbow.io
          ENSINDEXER_URL: http://localhost:42069
          ALCHEMY_API_KEY: ${{ secrets.ALCHEMY_API_KEY }}
          QUICKNODE_API_KEY: ${{ secrets.QUICKNODE_API_KEY }}
          QUICKNODE_ENDPOINT_NAME: ${{ secrets.QUICKNODE_ENDPOINT_NAME}}
          # healthcheck script env variables
          HEALTH_CHECK_TIMEOUT: 60
        run: ./.github/scripts/run_ensindexer_healthcheck.sh
